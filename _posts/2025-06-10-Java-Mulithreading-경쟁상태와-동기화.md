---
title: "Java Multithreading: 경쟁 상태와 동기화"
description: 멀티스레드 개념과 Atomicity, Visibility and Ordering 관점에서 문제 상황 바라보기
author: kancho
date: 2025-06-10 14:25:00
categories: [Programming Languages, Java]
tags: [Java, Multithreading, Synchronization, Java Memory Model]
pin: false
# math: true
# mermaid: true
---

# 개요
「 자바 코딩 인터뷰 완벽 가이드 」의 16장 동시성 파트를 읽는데 인터뷰 질문-답 형식이라 설명이 얕게 느껴졌고, 개념 연결이 매끄럽지 않아 따로 정리하게 됐다. 부족한 부분은 추가 자료 조사를 통해 개념과 실제 사례를 보충했고, 내가 이해하기 쉬운 순서로 흐름을 재구성하였다.

이번 글에서는 동시성/병렬성, 멀티 스레드, 멀티 스레드로 인해 발생하는 문제점과 해결책(동기화)에 대해 정리한다.

<img src="../assets/img/posts/synchronization-overview.png" />

## 왜 멀티 스레드를 알아야 할까?

멀티스레드는 하나의 프로그램이 여러 작업을 수행할 수 있도록 도와준다. 예를 들어, 웹서버가 수천 명의 사용자 요청을 **동시**에 처리하거나, 게임에서 캐릭터가 움직임과 **동시**에 배경 음악이 재생되려면 **멀티스레드**는 필수다. 

> 단, 여러 프로그램을 **병렬**적으로 실행시키는 **멀티 프로세스**와는 다른 개념이다.

<br/>

# 멀티 스레드란
멀티 스레드에 대해 이해하려면 먼저 **프로세스와 스레드의 차이**, 그리고 **동시성과 병렬성**에 대해 알아야 한다.

## 프로세스와 스레드
> 자세한 내용은 [프로세스-스레드-차이](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_process) 해당 글이 잘 정리되어 있어 참고하면 좋다.

- **프로세스**란 <u>실행 중인 프로그램</u>을 의미하며, **독립적인 메모리 공간**을 할당 받는다.
	- ex) 크롬 브라우저, 노션, 디스코드 등 실행중인 프로그램
- **스레드**는 프로세스 내에서 실행되는 <u>작업 단위</u>로, **같은 프로세스 내** 다른 스레드들과 **메모리를 공유**한다.
	- ex) 디스코드 - 음성 채팅과 텍스트 채팅 동시에 가능

<br/>

## 동시성과 병렬성
멀티 스레드가 어떻게 동작하는지 이해하려면, 먼저 “동시에 실행된다”라는 말이 정확히 어떤 의미인지 짚고 넘어가야 한다.

> **CPU**는 기본적으로 **한 번에 하나의 작업만 처리**할 수 있다. (**싱글 코어** 기준)

그런데 게임에서 캐릭터를 움직이면서, 배경 음악도 듣고, 게임 내 채팅까지 동시에 하고 있는 것 아닌가?라고 생각할 수 있다.

사실 이런 일들은 진짜 동시에 실행되는 것이 아니라, CPU가 아주 빠르게 작업 대상을 바꿔가며 실행하고 있을 뿐이다. 이러한 과정을 **Context Switching(문맥 교환)**이라고 부른다. CPU는 현재 실행 중인 스레드의 상태를 저장해두고, 다른 스레드의 상태를 불러와 이어서 수행한다. 이 전환이 아주 빠르게 이루어지기 때문에, 사용자 입장에서는 마치 여러 작업이 동시에 실행되는 것처럼 보인다.

그리고 이런 전환의 흐름을 관리하는 주체가 바로 운영체제의 **스케줄러**다. 스케줄러는 언제 어떤 스레드를 얼마나 실행할지를 판단해서 CPU를 할당해준다. 여기서 중요한 것은 스레드는 자신이 얼마나 오래 실행될지, 언제 다른 스레드로 교체될지 모른다는 점이다. 

<img src="../assets/img/posts/concurrency-parallelism.svg" />

이처럼 **싱글 코어**에서 여러 작업을 번갈아 수행해가면서 **마치 동시에 실행되는 것처럼 보이는** 현상을 **동시성(Concurrency)**이라고 부른다.
- ex) 음식점 직원이 한 명 뿐인데, 주문도 받고, 요리도 하고, 서빙까지 전부 혼자서 하는 것

반면, **멀티 코어**를 활용해서 **실제로 동시에 여러 작업을 수행하는 것**을 **병렬성(Parallelism)**이라고 한다.
- ex) 음식점에 직원이 여러 명 있어서, 각자 주문, 요리, 서빙을 담당하는 것

<br/>

## 멀티 프로세스와 멀티 스레드
**멀티 태스킹**을 구현하는 방법으로는 멀티 프로세스와 멀티 스레드가 있다.

- **멀티 프로세스**는 여러 개의 독립된 프로세스를 실행해서 작업을 나누는 것이다.
	- 각 프로세스는 메모리 공간을 공유하지 않기 때문에, 안정성은 높지만 리소스 소모가 크다.
- **멀티 스레드**는 하나의 프로세스 안에서 여러 작업을 나누어서 처리한다.
	- 스레드끼리 메모리를 공유하기 때문에 리소스 소모가 적지만, 이 때문에 예기치 못한 결과로 이어질 수 있다.

<br/>

# 🏃 멀티 스레딩은 경쟁 상태를 일으킨다.
멀티 스레드는 프로세스 내 공유 자원을 함께 사용할 수 있다. 만약 이러한 공유 자원에 두 개 이상의 스레드가 **동시에** 접근한다면 어떻게 될까?

블로그 방문자 수를 카운트하는 예제를 들어보자.

```java
public class Counter {
	private int count = 0;

	public void increment() {
		count++;
	}
	
	public int getCount() {
		return count;
	}
}

Thread A: increment 호출 // 사용자 A가 방문
Thread B: increment 호출 // 사용자 B가 방문
```

동일한 자원인 블로그 방문자 수 자원에 두 개의 스레드가 동시에 접근하는 상황이다.

2명의 사용자가 방문했으므로 count가 2가 되기를 바라지만,
실제로 스레드가 동시에 실행되면 결과가 1로 나오는 등 잘못된 결과가 나올 수 있다.

이처럼 여러 스레드가 같은 공유 자원을 동시에 수정할 때, 일관된 결과가 나오지 않는 상태를 ~={orange}경쟁 상태(Race Condition)=~라고 한다.

왜 이런 문제가 생기는 것일까?

<br/>

# ✍️ 경쟁 상태가 발생하는 3가지 원인
멀티 스레드 환경에서는 다음 세 가지 특성이 지켜지지 않으면, 정상적인 결과를 기대할 수 없다.

## 1️⃣ 원자성 (Atomicity)
원자성은 어떤 동작이 도중에 중단될 수 없는, 즉 “한 번에” 실행됨을 보장하는 성질을 말한다.

`count++` 는 단순해보이지만, 실제로는 세 단계로 나뉜다:
1. 읽기: `count` 값 가져오기
2. 증가: 1의 결과값에 1 더하기
3. 저장: 2의 결과 값을 `count` 에 쓰기

만약 스레드 A가 읽은 후, 증가 전에 스레드 B가 끼어들어서 읽으면, B가 A의 변경을 덮어쓸 수 있다.

## 2️⃣ 가시성 (Visibility)


## 3️⃣ 순서성 (Ordering)

<br/>


# ✅ 동기화로 경쟁 상태를 해결하자


# 마무리
멀티 스레드는 성능과 응답성을 높이지만, 동기화가 없으면 원자성, 가시성, 순서성 문제로 결쟁 상태가 발생할 수 있다. 따라서 멀티 스레드 프로그래밍을 하기 위해서는 동기화 기법은 필수로 알아야 한다. 다음 글에서 동기화 Java에서의 동기화 메커니즘과 동기화로 인해 발생할 수 있는 교착 상태(DeadLock)에 대해 자세히 정리할 예정이다.


<br/>

# 참고
- 자바 코딩 인터뷰 완벽 가이드
- Effective Java 3/E
- [프로세스-스레드-차이](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_process)
- [Atomicity, Visiblity and Ordering](https://jeremymanson.blogspot.com/2007/08/atomicity-visibility-and-ordering.html)




