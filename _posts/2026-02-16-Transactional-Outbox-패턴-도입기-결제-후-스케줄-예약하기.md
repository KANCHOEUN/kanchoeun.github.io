---
title: "Transactional Outbox 패턴 도입기; 결제 후 스케줄 예약하기"
description: Dual Write Problem 해결하기
author: kancho
date: 2025-12-10 17:48:00
categories: [Project, Mockly]
tags: [Transaction, Outbox]
pin: false
# math: true
# mermaid: true
---

# 개요
Mockly에서는 통합 결제 연동 플랫폼인 PortOne을 활용하여 구독 기반 결제 시스템을 구축하고 있다.

구독 결제는 일반 단건 결제와 달리, 최초 결제 이후 동일한 결제 수단으로 반복 결제가 발생한다. 이를 위해 PG사는 사용자의 카드 정보와 매핑되는 Billing Key를 발급하고, 서비스는 해당 Key를 기반으로 매달 자동 결제를 수행하게 된다. 즉 최초 결제 시에는 카드 인증과 Billing Key 발급이 이루어지고, 이후 결제부터는 Billing Key를 활용한 서버 간 결제 요청만으로 과금이 진행된다.

사용자가 구독을 활성화시키는 플로우는 다음과 같이 3단계로 이루어져 있다:

1. [PortOne API 호출] Billing Key 기반 즉시 <u>결제 요청</u>
2. 내부 <u>데이터</u>인 Payment와 Subscription의 <u>상태</u>를 각각 PAID와 ACTIVE로 <u>변경</u>
3. [PortOne API 호출] 다음 달 결제를 위한 <u>스케줄 예약 요청</u>

흐름 자체는 단순해보였지만, 초기 구현 단계에서는 이 세 과정을 하나의 트랜잭션 안에서 처리하고 있었다. 결제와 스케줄 예약이 하나의 비즈니스 플로우로 이어진다고 판단했기 때문이다.

하지만 구조를 검토하는 과정에서 한 가지 문제점을 발견했다. 결제 승인은 외부 시스템에서 이미 확정되었는데, 그 이후의 내부 상태 변경과 또 다른 외부 시스템 호출(스케줄 예약 요청)이 동일한 트랜잭션 경계 안에 포함되어 있었다. 즉 되돌릴 수 없는 외부 상태 변화와 롤백 가능한 내부 트랜잭션이 하나의 흐름에 묶여 있던 것이다.

![payment-fail-case-sequence-diagram](/assets/img/posts/payment-fail-case-sequence-diagram.png)

예를 들어 결제는 정상적으로 승인되었지만 이후 스케줄 예약이 실패한다면, 사용자의 돈은 이미 빠져나갔음에도 불구하고 트랜잭션이 롤백되어 DB에는 결제 기록조차 남지 않게 된다. 반대로 스케줄 예약 실패를 무시한다면, 다음 달 결제가 예약되지 않아 매출 누락이 발생할 수 있다.

### 요구사항을 다시 정리해보자
```
결제 성공 후,
다음 결제 스케줄이 예약되어야 한다.

BUT 스케줄 예약 실패가
결제 실패로 이어져서는 안된다.
```

정리하면 다음과 같았다.
1. 결제와 스케줄 예약은 각각 독립적으로 성공해야 한다.
2. 스케줄 예약은 즉시 실패해도 되지만, 최종적으로는 성공해야 한다.

즉 결제는 즉시 확정되어야 하는 강한 일관성이 요구되는 반면, 스케줄 예약은 최종적으로 성공하면 되는 작업이다. 이렇게 두 작업의 일관성 요구 수준이 달랐기 때문에 하나의 트랜잭션으로 묶어 처리할 수 없었다.

<br/>

## 1️⃣ Webhook으로 스케줄 예약 처리하기
스케줄 예약 호출을 메인 트랜잭션에서 분리하기 위해 가장 먼저 고려한 방법은 Webhook이다.

PortOne은 안정적인 결제 처리를 위해 Webhook 연동을 강력히 권장하고 있다. 결제에 대한 결과를 이벤트 형태로 전달해주는데, 이러한 webhook을 수신하는 서비스를 이미 구축해두었다. 따라서 결제 트랜잭션에서 스케줄 예약을 수행하지 않고, 결제 성공 이벤트를 수신했을 때 스케줄 예약을 수행하도록 분리하는 구조로 변경해보았다.

흐름은 다음과 같다.

![webhook-sequence-diagram](/assets/img/posts/webhook-sequence-diagram.png)

해당 방식은 결제와 스케줄 예약을 자연스럽게 분리할 수 있었다. 결제가 이미 확정된 이후에 스케줄을 예약하기 때문에 스케줄 예약 실패가 결제 롤백으로 이어지지 않는다.

하지만 Webhook은 외부 시스템이 전달하는 이벤트이기 때문에 전달 자체를 완벽히 신뢰할 수 없었다. 네트워크 장애로 인해 이벤트가 유실될 가능성이 존재하고, 이벤트 처리 과정에서 예외가 발생하면 스케줄 예약이 수행되지 않을 수도 있다. 또한 이벤트 전달이 지연되는 상황도 고려해야 한다.

물론 PortOne은 SLA를 통해 Webhook 전달 안정성을 보장하고 있지만, 설계 관점에서 보면 Webhook만으로는 스케줄 예약의 완료를 보장하기 어렵다. Webhook이 보장하는 것은 이벤트 전달이지, 그 이후 작업의 성공은 아니다. 이벤트를 수신한 이후 처리 과정에서 예외가 발생하거나 서버가 다운된다면? 스케줄 예약은 수행되지 않을 수 있다. 즉 Webhook은 전달을 보장할 수는 있어도, 작업 완료까지 보장하는 구조는 아니었다.

결국 Webhook은 결제 상태를 보조적으로 동기화하거나 정합성을 검증하는 용도로는 적합하지만, 스케줄 예약을 처리하는 핵심 로직으로 두기에는 부족했다. 

<br/>

## 2️⃣ Event로 스케줄 예약 처리하기
Webhook처럼 외부 시스템이 전달하는 이벤트에 의존하는 대신, 내부에서 직접 이벤트를 발행하는 방식도 고려해보았다. 결제 트랜잭션이 커밋되는 시점에 이벤트를 발행하고, 해당 이벤트를 구독하는 리스너가 스케줄 예약을 수행하도록 분리하는 구조다.

흐름은 다음과 같다.

![event-sequence-diagram](/assets/img/posts/event-sequence-diagram.png)

Spring에서는 `@TransactionalEventListener(AFTER_COMMIT)` 를 활용하면 트랜잭션이 커밋된 이후에 로직을 실행할 수 있다. 이렇게 하면 스케줄 예약을 결제 트랜잭션과 분리할 수 있고, 예약 실패가 결제 롤백으로 이어지는 문제를 피할 수 있다.

하지만 이 방식 역시 최종 성공을 보장할 수 없었다. 스케줄 예약은 한 번 시도해보는 작업이 아니라 반드시 성공해야 하는 작업이다. 즉 At Most Once가 아니라 At Least Once 보장이 필요했다.

예를 들어 스케줄 예약 호출 중 예외가 발생한다면? 혹은 일시적 네트워크 오류가 발생한다면 재시도 로직을 추가해볼 수 있다. 하지만 트랜잭션 커밋 직후 서버가 다운된다면 어떻게 될까? 이벤트는 메모리 상에서 발행되었을 뿐, 어디에도 영속적으로 기록되지 않았다. 이벤트가 저장되지 않는 구조에서는 실패 여부를 확인할 수도 없고, 재시도 대상이 무엇인지조차도 알 수 없다.

<br/>

## 3️⃣ 이벤트를 메모리가 아니라 DB에 저장하자
실패를 확인하고, 재시도를 할 수 있도록 하기 위해 이벤트 자체를 영속적으로 기록하는 구조가 필요했다.

리스너에서 스케줄 예약 호출이 실패했는지, 혹은 커밋 직후 서버가 다운돼서 아예 실행되지 않았는지 알 수 없다면 재시도는 시작조차 할 수 없다. 재시도를 위해서는 수행해야 할 작업이 어딘가엔 기록되어 있어야 했다. 이를 위해 결제 트랜잭션에서 Payment와 Subscription의 상태를 변경할 때 스케줄 예약 요청도 함께 기록하기로 하였다.

#### Dual Write Problem

#### Transactional Outbox Pattern


## 정리

